{
    "JSTypes": {
        "title": "Primitive and Non-Primitive Types",
        "text": "<h2>Primitive Types</h2><p>Primitive types are immutable and represent simple, basic values. JavaScript has the following primitive types:</p><ol><li><strong>Number:</strong> Represents both integers and floating-point numbers.<ul><li>Examples: 42, 3.14</li><li>Special values include NaN (Not a Number) and Infinity.</li></ul></li><li><strong>String:</strong> Represents a sequence of characters.<ul><li>Examples: \"hello\", 'world'</li></ul></li><li><strong>Boolean:</strong> Represents logical values.<ul><li>Only two possible values: true or false</li></ul></li><li><strong>Undefined:</strong> A variable that has been declared but not assigned a value is undefined.<ul><li>Example: let x; (Here, x is undefined)</li></ul></li><li><strong>Null:</strong> Represents an intentionally empty or non-existent value.<ul><li>Example: let y = null;</li></ul></li><li><strong>Symbol (ES6):</strong> Represents a unique identifier.<ul><li>Example: let sym = Symbol(\"description\");</li></ul></li><li><strong>BigInt (ES2020):</strong> Allows you to represent integers beyond the safe integer limit for Numbers.<ul><li>Example: let bigInt = 1234567890123456789012345678901234567890n;</li></ul></li></ol><h2>Non-Primitive Types</h2><p>Non-primitive types, also called reference types, hold references to objects and are mutable. JavaScript has one primary non-primitive type:</p><ol><li><strong>Object:</strong> Collections of properties, where each property has a key and a value. Objects can hold complex data structures and include subtypes such as:<ul><li><strong>Arrays:</strong> Ordered collections of values.<ul><li>Example: let arr = [1, 2, 3];</li></ul></li><li><strong>Functions:</strong> Callable objects.<ul><li>Example: function greet() { return \"Hello!\"; }</li></ul></li><li><strong>Dates:</strong> Represent date and time values.<ul><li>Example: let now = new Date();</li></ul></li></ul></li></ol>"
    },
    "TypeChecking": {
        "title": "Type Checking in JavaScript",
        "text":"<p>To check a type in JavaScript, you can use:</p><ul><li><code>typeof</code> operator for most primitive types.</li><li><code>Array.isArray()</code> specifically for arrays.</li><li><code>instanceof</code> for complex objects like custom objects or classes.</li></ul>"
    },
    "VariablesDeclaration": {
        "title": "Variables",
        "text": "<h2>1. Variable Declarations and Scope Types</h2><ul><li><code>let</code>: This variable is block-scoped, meaning it only exists within the specific block (like a function, loop, or { } code block) in which it’s defined. You can reassign its value.</li><li><code>const</code>: This is also block-scoped. Its value is constant (cannot be reassigned), though objects or arrays assigned to it can have their internal contents modified.</li><li><code>var</code>: An older way to declare variables, which is function-scoped. It is accessible within the function it’s defined in, or globally if not in a function, and can be redeclared and reassigned.</li></ul><h2>2. Scope Levels</h2><ul><li><strong>Global Scope</strong>: Variables declared outside any function or block are globally scoped, meaning they can be accessed anywhere in the code.</li><li><strong>Function Scope</strong>: Variables declared within a function (e.g., with var) are only accessible within that function.</li><li><strong>Block Scope</strong>: Variables declared with let or const inside any block { } are accessible only within that block.</li></ul><pre><code>let age = 30; // global scope\nfunction updateAge() {\n    let age = 40; // function-scoped age, separate from global `age`\n    if (true) {\n        const city = \"Paris\"; // block-scoped, only accessible within `if` block\n    }\n    console.log(city); // Error: city is not defined outside of `if` block\n}</code></pre><h2>3. Reassignment and Mutability</h2><ul><li><code>let</code> and <code>var</code>: Both can be reassigned within their scope.</li><li><code>const</code>: Can’t be reassigned, but if it holds an object or array, the internal contents can be modified within its scope.<pre><code>const arr = [1, 2, 3];\narr = []; // error\narr.push(4); // no error, legit</code></pre></li></ul><h2>4. Key Points on Scope</h2><ul><li>Global variables (outside any function or block) can lead to issues if used excessively, as they’re accessible throughout the code and can cause conflicts.</li><li>Local variables (function-scoped or block-scoped) help keep your code modular and predictable by limiting where the variables are accessible.</li><li>Block scoping with let and const makes code safer by reducing the chances of accidentally using or modifying variables outside their intended context.</li></ul><pre><code>function testScope() {\n    if (true) {\n        var x = \"I’m function-scoped with var\";\n        let y = \"I’m block-scoped with let\";\n        const z = \"I’m block-scoped with const\";\n    }\n    console.log(x); // \"I’m function-scoped with var\" - accessible here due to function scope\n    console.log(y); // Error: y is not defined - y is only accessible within the `if` block\n    console.log(z); // Error: z is not defined - z is also block-scoped to `if`\n}\ntestScope();</code></pre><h3>=============</h3><pre><code>function loopScopeWithVar() {\n    for (var i = 0; i < 3; i++) {\n        console.log(\"Inside loop with var:\", i); // 0, 1, 2\n    }\n    console.log(\"Outside loop with var:\", i); // 3 - `i` is still accessible here\n}\nloopScopeWithVar();</code></pre><h3>=============</h3><pre><code>function loopScopeWithLet() {\n    for (let i = 0; i < 3; i++) {\n        console.log(\"Inside loop with let:\", i); // 0, 1, 2\n    }\n    console.log(\"Outside loop with let:\", i); // Error: i is not defined\n}\nloopScopeWithLet();</code></pre><h3>=============</h3><h2>Asynchronous Example</h2><p>Consider an example with a delay (<code>setTimeout</code>) in the loop to see how var and let handle asynchronous behavior differently.</p><h3>Using var</h3><pre><code>function asyncLoopWithVar() {\n    for (var i = 0; i < 3; i++) {\n        setTimeout(function() {\n            console.log(\"Async with var:\", i); // 3, 3, 3\n        }, 1000);\n    }\n}\nasyncLoopWithVar();</code></pre><p><strong>Explanation:</strong><ul><li>Because <code>var</code> is function-scoped, there’s only one <code>i</code> variable shared across all iterations. By the time the <code>setTimeout</code> callbacks run, the loop has completed, and <code>i</code> has the value 3 in each callback, so “3” is logged three times.</li><li>This happens because <code>var</code> does not create a new instance of <code>i</code> for each loop iteration.</li></ul></p><h3>Using let</h3><pre><code>function asyncLoopWithLet() {\n    for (let i = 0; i < 3; i++) {\n        setTimeout(function() {\n            console.log(\"Async with let:\", i); // 0, 1, 2\n        }, 1000);\n    }\n}\nasyncLoopWithLet();</code></pre><p><strong>Explanation:</strong><ul><li>With <code>let</code>, each iteration of the loop has its own block-scoped instance of <code>i</code>. Each <code>setTimeout</code> callback captures the value of <code>i</code> specific to that loop iteration, so it logs “0”, “1”, and “2” as expected.</li><li>This happens because <code>let</code> provides a new instance of <code>i</code> within the loop for each cycle, preserving the correct value even when the loop is asynchronous.</li></ul></p>"
    },
    "JSSClassesAndPrototypes": {
        "title": "Js classes and prototypes",
        "text":"<p>In JavaScript, classes and prototypes provide a way to create objects and structure code for reusability. Here’s a straightforward breakdown:</p><h2>1. Prototypes</h2><ul><li>Every JavaScript object has an internal property called [[Prototype]], linking it to another object. This linked object is called its prototype.</li><li>Prototypes allow objects to inherit properties and methods from other objects. When you try to access a property or method on an object, JavaScript will look for it on the object itself and, if not found, continue searching up the prototype chain.</li></ul><pre><code>function Animal(type) {\n    this.type = type;\n}\nAnimal.prototype.makeSound = function() {\n    console.log(\"Some sound\");\n};\nconst dog = new Animal(\"Dog\");\ndog.makeSound(); // Outputs: \"Some sound\"</code></pre><p>Here, makeSound is on Animal’s prototype, so all Animal instances like dog can use it.</p><h2>2. Classes</h2><ul><li>JavaScript class syntax provides a clearer, more concise way to create objects with prototypes and inheritance.</li><li>Classes are essentially “syntactic sugar” over JavaScript’s prototype-based inheritance. This means that under the hood, classes are still based on prototypes.</li><li>A class can have a constructor (like a function), and methods are added to the class’s prototype.</li></ul><pre><code>class Animal {\n    constructor(type) {\n        this.type = type;\n    }\n    makeSound() {\n        console.log(\"Some sound\");\n    }\n}\nconst cat = new Animal(\"Cat\");\ncat.makeSound(); // Outputs: \"Some sound\"</code></pre><p>Here, the makeSound method is part of the Animal class prototype, so instances of Animal like cat inherit it.</p><h2>3. Inheritance</h2><ul><li>Classes support inheritance, allowing you to create subclasses.</li><li>By using the extends keyword, you can create a new class based on an existing one, inheriting its properties and methods.</li></ul><pre><code>class Dog extends Animal {\n    makeSound() {\n        console.log(\"Woof!\");\n    }\n}\nconst myDog = new Dog(\"Dog\");\nmyDog.makeSound(); // Outputs: \"Woof!\"</code></pre><p>The Dog class inherits from Animal, but it overrides the makeSound method.</p><h2>Key Points</h2><ul><li>Prototypes enable inheritance by linking objects to each other.</li><li>Classes offer a modern, cleaner syntax for creating objects and handling inheritance.</li><li>Instances of a class or constructor function share methods through the prototype chain.</li></ul><p>Both approaches enable code reuse and modularization, with classes generally being easier to read and understand in modern JavaScript.</p>"
    },
    "CoercionAndConversion": {
        "title": "Type coercion and conversion",
        "text":"<p>Type coercion and conversion are important concepts in JavaScript, especially for junior developers. They play a big role in how JavaScript handles values during comparisons, assignments, and other operations. Here’s a breakdown of these concepts with examples:</p><h2>1. Type Coercion vs. Type Conversion</h2><ul><li><strong>Type Coercion</strong>: This is an automatic or implicit conversion of values from one data type to another. JavaScript automatically coerces types in certain operations, often leading to unexpected results if not carefully handled.</li><li><strong>Type Conversion</strong>: This is an explicit conversion where we intentionally convert one data type to another using built-in methods like <code>String()</code>, <code>Number()</code>, or <code>Boolean()</code>.</li></ul><h2>2. Examples of Type Coercion in Comparisons</h2><p>Type coercion is particularly noticeable with the <code>==</code> operator, where JavaScript tries to convert both sides to the same type before comparing. The <code>===</code> operator (strict equality) does not perform type coercion, meaning both the value and type must match.</p><ul><li><strong>Loose Equality (==)</strong>:</li></ul><pre><code>console.log(5 == '5'); // true, because '5' is coerced to 5\nconsole.log(false == 0); // true, because false is coerced to 0\nconsole.log('' == 0); // true, because '' is coerced to 0\nconsole.log(null == undefined); // true, special case in JavaScript</code></pre><ul><li><strong>Strict Equality (===)</strong>:</li></ul><pre><code>console.log(5 === '5'); // false, because the types (number and string) are different\nconsole.log(false === 0); // false, because false is a boolean and 0 is a number\nconsole.log('' === 0); // false, different types\nconsole.log(null === undefined); // false, different types</code></pre><h2>3. Common Coercion Cases</h2><ul><li><strong>Boolean Coercion</strong>: JavaScript has rules for truthy and falsy values, so certain values convert to true or false in contexts that expect booleans.</li><li>Falsy values include: <code>0</code>, <code>''</code> (empty string), <code>null</code>, <code>undefined</code>, <code>NaN</code>, and <code>false</code>.</li><li>Everything else is truthy.</li></ul><pre><code>console.log(Boolean(0)); // false\nconsole.log(Boolean('')); // false\nconsole.log(Boolean('Hello')); // true</code></pre><ul><li><strong>Number Coercion</strong>: When performing mathematical operations, JavaScript tries to coerce values to numbers.</li></ul><pre><code>console.log('5' - 3); // 2, because '5' is coerced to 5\nconsole.log('5' + 3); // '53', because + with a string leads to string concatenation</code></pre><h2>4. Explicit Type Conversion</h2><ul><li><strong>String Conversion</strong>:</li></ul><pre><code>console.log(String(123)); // '123'\nconsole.log((123).toString()); // '123'</code></pre><ul><li><strong>Number Conversion</strong>:</li></ul><pre><code>console.log(Number('123')); // 123\nconsole.log(Number('')); // 0\nconsole.log(parseInt('123px', 10)); // 123, ignores non-numeric part</code></pre><ul><li><strong>Boolean Conversion</strong>:</li></ul><pre><code>console.log(Boolean(1)); // true\nconsole.log(Boolean(0)); // false</code></pre><h2>5. Best Practices</h2><ul><li>Use <code>===</code> for comparisons to avoid unexpected coercion.</li><li>Be mindful of truthy and falsy values in conditions.</li><li>Convert types explicitly when you need a specific type.</li></ul>"
    },
    "Conditionals": {
        "title": "Conditionals",
        "text":"<p>Conditionals are essential in JavaScript for controlling the flow of a program. They allow you to execute different code blocks based on certain conditions. Here’s an overview of how <code>if</code>, <code>else</code>, and <code>switch</code> work, along with best practices and examples.</p><h2>1. if Statement</h2><p>The <code>if</code> statement is used to execute a block of code only if a specified condition is true.</p><pre><code>let age = 18;\nif (age >= 18) {\n  console.log(\"You are an adult.\");\n}</code></pre><p>In this example, the message \"You are an adult.\" will only be logged if <code>age</code> is 18 or greater.</p><h2>2. if...else Statement</h2><p>The <code>if...else</code> statement allows you to specify an alternative block of code that runs if the <code>if</code> condition is false.</p><pre><code>let age = 16;\nif (age >= 18) {\n  console.log(\"You are an adult.\");\n} else {\n  console.log(\"You are not an adult.\");\n}</code></pre><p>Here, if <code>age</code> is less than 18, the message \"You are not an adult.\" will be logged.</p><h2>3. else if Statement</h2><p>The <code>else if</code> statement allows you to chain multiple conditions. The first condition that evaluates to true will execute its associated code block, and the rest will be ignored.</p><pre><code>let score = 85;\nif (score >= 90) {\n  console.log(\"Grade: A\");\n} else if (score >= 80) {\n  console.log(\"Grade: B\");\n} else if (score >= 70) {\n  console.log(\"Grade: C\");\n} else {\n  console.log(\"Grade: F\");\n}</code></pre><p>In this case, if <code>score</code> is between 80 and 89, the output will be \"Grade: B\". Only one of the conditions will be executed.</p><h2>4. switch Statement</h2><p>The <code>switch</code> statement is an alternative to multiple <code>if...else if</code> statements. It compares a single expression against multiple possible values. The <code>switch</code> statement is often used when you have a single variable that could be one of many values.</p><pre><code>let fruit = \"apple\";\nswitch (fruit) {\n  case \"apple\":\n    console.log(\"You chose an apple.\");\n    break;\n  case \"banana\":\n    console.log(\"You chose a banana.\");\n    break;\n  case \"orange\":\n    console.log(\"You chose an orange.\");\n    break;\n  default:\n    console.log(\"Unknown fruit.\");\n}</code></pre><p>In this example, if <code>fruit</code> is \"apple\", the message \"You chose an apple.\" is logged. The <code>break</code> statement prevents the code from executing subsequent cases.</p><h2>5. Nested Conditionals</h2><p>You can nest <code>if</code>, <code>else if</code>, <code>else</code>, and even <code>switch</code> statements inside each other to create more complex logic. However, avoid deep nesting as it can make the code harder to read.</p><pre><code>let age = 20;\nlet hasPermission = true;\nif (age >= 18) {\n  if (hasPermission) {\n    console.log(\"You can enter the event.\");\n  } else {\n    console.log(\"You need permission to enter.\");\n  }\n} else {\n  console.log(\"You are too young to enter.\");\n}</code></pre><h2>6. Ternary Operator (Shorter Conditional)</h2><p>For simple conditions, you can use the ternary operator (<code>? :</code>) as a shorthand for <code>if...else</code>.</p><pre><code>let age = 20;\nlet message = age >= 18 ? \"You are an adult.\" : \"You are not an adult.\";\nconsole.log(message);</code></pre><p>This will output \"You are an adult.\" if <code>age</code> is 18 or older; otherwise, it outputs \"You are not an adult.\"</p><h2>7. Best Practices for Conditionals</h2><ul><li>Use <code>===</code> for Comparison: To avoid type coercion issues, prefer <code>===</code> over <code>==</code>.</li><li>Keep Conditions Simple: Break down complex conditions into smaller functions if necessary.</li><li>Switch for Specific Values: Use <code>switch</code> statements when comparing a single variable against multiple constant values. Use <code>if...else</code> when you have complex conditions or ranges.</li><li>Avoid Deep Nesting: Deeply nested <code>if</code> statements can make code hard to read. Use <code>return</code> statements in functions to exit early when possible.</li><li>Ternary Operator for Simple Assignments: Use the ternary operator for short, single-line conditional assignments, but avoid it in complex conditions to maintain readability.</li></ul><p>Conditionals are powerful for building logic in applications, and understanding these structures well will help you write cleaner, more efficient JavaScript code.</p>"
    },
    "Loops": {
        "title": "Loops",
        "text":"<p>Loops are fundamental in JavaScript, allowing you to execute a block of code multiple times based on a condition. Here’s a breakdown of the main types of loops in JavaScript:</p><h2>1. for Loop</h2><p>The <code>for</code> loop is commonly used when you know the exact number of iterations or want to iterate over a range of values.</p><p><strong>Syntax:</strong></p><pre><code>for (initialization; condition; increment) {\n  // Code to execute on each iteration\n}</code></pre><p><strong>Example:</strong></p><pre><code>for (let i = 0; i < 5; i++) {\n  console.log(i);\n}</code></pre><p>This loop will log numbers 0 through 4. Here’s how each part works:</p><ul><li><strong>Initialization</strong>: <code>let i = 0</code> sets the starting value.</li><li><strong>Condition</strong>: <code>i < 5</code> checks if the loop should continue.</li><li><strong>Increment</strong>: <code>i++</code> increases <code>i</code> by 1 after each loop.</li></ul><h2>2. while Loop</h2><p>The <code>while</code> loop is useful when the number of iterations is not known beforehand. It continues to execute as long as the condition is true.</p><p><strong>Syntax:</strong></p><pre><code>while (condition) {\n  // Code to execute on each iteration\n}</code></pre><p><strong>Example:</strong></p><pre><code>let i = 0;\nwhile (i < 5) {\n  console.log(i);\n  i++;\n}</code></pre><p>This loop works similarly to the for loop above, logging numbers 0 through 4. Note that you must manually update the variable <code>i</code> within the loop; otherwise, you’ll end up with an infinite loop.</p><h2>3. do...while Loop</h2><p>The <code>do...while</code> loop is similar to the <code>while</code> loop, but it guarantees that the loop body will execute at least once, even if the condition is false.</p><p><strong>Syntax:</strong></p><pre><code>do {\n  // Code to execute\n} while (condition);</code></pre><p><strong>Example:</strong></p><pre><code>let i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i < 5);</code></pre><p>This example will log numbers 0 through 4, just like the previous loops. However, the <code>do</code> block executes first before checking the <code>while</code> condition.</p><h2>4. for...of Loop</h2><p>The <code>for...of</code> loop is specifically used for iterating over iterable objects, such as arrays, strings, and other collections.</p><p><strong>Syntax:</strong></p><pre><code>for (const element of iterable) {\n  // Code to execute for each element\n}</code></pre><p><strong>Example:</strong></p><pre><code>const colors = ['red', 'green', 'blue'];\nfor (const color of colors) {\n  console.log(color);\n}</code></pre><p>This will log each color in the array: 'red', 'green', and 'blue'. The <code>for...of</code> loop is often preferred for iterating over arrays since it’s cleaner and avoids the need for indexing.</p><h2>5. for...in Loop</h2><p>The <code>for...in</code> loop is used for iterating over the keys (property names) of an object. It’s also technically usable with arrays, but it’s generally not recommended for that purpose, as it iterates over all enumerable properties, including inherited ones.</p><p><strong>Syntax:</strong></p><pre><code>for (const key in object) {\n  // Code to execute for each key\n}</code></pre><p><strong>Example:</strong></p><pre><code>const person = { name: 'Alice', age: 25, city: 'Paris' };\nfor (const key in person) {\n  console.log(key, person[key]);\n}</code></pre><p>This will log each key-value pair:</p><ul><li><code>name Alice</code></li><li><code>age 25</code></li><li><code>city Paris</code></li></ul><p><strong>Note:</strong> Avoid using <code>for...in</code> on arrays. It will also iterate over inherited properties, which can lead to unexpected results. For arrays, use <code>for</code>, <code>for...of</code>, or array methods like <code>.forEach()</code>.</p><h2>6. Loop Control Statements</h2><ul><li><strong>break</strong>: Exits the loop immediately.</li><li><strong>continue</strong>: Skips to the next iteration of the loop.</li></ul><p><strong>Example with break and continue:</strong></p><pre><code>for (let i = 0; i < 5; i++) {\n  if (i === 3) break; // Exit the loop if i is 3\n  if (i === 1) continue; // Skip the rest of the loop for i = 1\n  console.log(i);\n}</code></pre><p>This will output 0, 2, and then stop at 3.</p><h2>7. Best Practices</h2><ul><li>Use <code>for</code> loops when you need control over the index.</li><li>Use <code>for...of</code> loops when iterating directly over values in arrays or other iterables.</li><li>Use <code>for...in</code> for iterating over object properties but avoid it with arrays.</li><li>Avoid infinite loops by making sure your condition will eventually be false.</li><li>Consider array methods like <code>.forEach()</code>, <code>.map()</code>, or <code>.filter()</code> as alternatives to loops for more readable and functional code.</li></ul><p>By understanding these loops and their specific use cases, you can iterate through data effectively and write cleaner, more efficient code in JavaScript.</p><h2>Declarative vs. Imperative Approaches</h2><p>When working with loops, the choice between a declarative and an imperative approach can impact code readability, maintainability, and clarity. Here’s how each approach compares, especially in the context of JavaScript loops:</p><h3>1. Imperative Approach</h3><ul><li>The imperative approach focuses on describing how to accomplish a task step-by-step.</li><li>Traditional loops like <code>for</code>, <code>while</code>, and <code>for...of</code> are imperative because they require you to define the steps explicitly for each iteration.</li><li>With an imperative approach, you need to manage the control flow, set up initial values, define conditions, and handle increments or updates directly.</li></ul><p><strong>Example (Imperative):</strong></p><pre><code>const numbers = [1, 2, 3, 4, 5];\nlet sum = 0;\nfor (let i = 0; i < numbers.length; i++) {\n  sum += numbers[i];\n}\nconsole.log(sum); // Outputs: 15</code></pre><p>Here, each step of the iteration is controlled manually: initializing <code>i</code>, setting the loop condition, updating <code>i</code>, and managing <code>sum</code> updates.</p><h3>2. Declarative Approach</h3><ul><li>The declarative approach focuses on describing what you want to achieve, rather than how to do it step-by-step.</li><li>JavaScript’s array methods like <code>.map()</code>, <code>.filter()</code>, <code>.reduce()</code>, and <code>.forEach()</code> are declarative, as they abstract the iteration details, letting you focus on the desired outcome.</li><li>With a declarative approach, you express the intent directly, making code easier to read and understand without managing loop mechanics manually.</li></ul><p><strong>Example (Declarative):</strong></p><pre><code>const numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((acc, number) => acc + number, 0);\nconsole.log(sum); // Outputs: 15</code></pre><p>Here, <code>.reduce()</code> directly conveys that you want to calculate the sum of all items in the array, without managing the loop steps manually.</p><h3>3. Advantages of Declarative Over Imperative in JavaScript</h3><ul><li><strong>Readability</strong>: Declarative code is often more readable and concise, as it abstracts away the control flow, focusing on the task rather than the mechanics.</li><li><strong>Less Prone to Errors</strong>: Since you’re not manually handling increments, indexes, or loop conditions, there’s less chance of off-by-one errors or infinite loops.</li><li><strong>Functional Style</strong>: Declarative methods like <code>.map()</code>, <code>.filter()</code>, and <code>.reduce()</code> encourage a functional programming style, which can lead to cleaner, modular code that’s easier to test and debug.</li><li><strong>Easier Refactoring</strong>: Declarative code is often easier to refactor and modify because it encapsulates behavior rather than steps.</li></ul><h3>4. Choosing Between Declarative and Imperative</h3><ul><li><strong>When to Use Declarative</strong>: Prefer declarative methods like <code>.map()</code>, <code>.filter()</code>, <code>.reduce()</code>, and <code>.forEach()</code> when working with arrays, as they are designed to handle common iteration tasks cleanly.</li><li><strong>When to Use Imperative</strong>: Use traditional loops (<code>for</code>, <code>while</code>) when you need fine-grained control over the iteration or when performance is a key concern, as traditional loops can sometimes be faster in performance-critical applications.</li></ul><h3>5. Example Comparison</h3><p><strong>Imperative with for Loop:</strong></p><pre><code>const numbers = [1, 2, 3, 4, 5];\nconst doubled = [];\nfor (let i = 0; i < numbers.length; i++) {\n  doubled.push(numbers[i] * 2);\n}\nconsole.log(doubled); // [2, 4, 6, 8, 10]</code></pre><p><strong>Declarative with .map():</strong></p><pre><code>const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(number => number * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]</code></pre><p>In this example, <code>.map()</code> makes the intent clear (“double each number”) without requiring explicit setup and incrementing as in the <code>for</code> loop.</p><h2>Summary</h2><ul><li><strong>Imperative</strong>: Focuses on the steps to complete a task (e.g., <code>for</code> loop), useful for precise control.</li><li><strong>Declarative</strong>: Focuses on the outcome (e.g., <code>.map()</code>, <code>.reduce()</code>), often more readable and concise.</li></ul><p>For most cases, the declarative approach is preferred in JavaScript when working with collections, as it simplifies code and aligns with JavaScript’s functional programming capabilities.</p>"
    },
    "TruthyandFalsyValues": {
        "title": "Truthy and Falsy Values",
        "text":"<p>In JavaScript, understanding truthy and falsy values is essential because they influence conditionals and logical operations. Truthy and falsy values determine whether an expression evaluates to true or false in a boolean context, such as in <code>if</code> statements, loops, and logical operators.</p><h2>1. Truthy and Falsy Values</h2><ul><li><strong>Truthy</strong>: A value is considered “truthy” if it evaluates to true in a boolean context.</li><li><strong>Falsy</strong>: A value is “falsy” if it evaluates to false in a boolean context.</li></ul><h2>2. Falsy Values in JavaScript</h2><p>In JavaScript, there are exactly seven values that are considered falsy:</p><ul><li><code>false</code></li><li><code>0</code> (and <code>-0</code>)</li><li><code>\"\"</code> (empty string)</li><li><code>null</code></li><li><code>undefined</code></li><li><code>NaN</code> (Not-a-Number)</li></ul><p>Any other value, including objects, arrays, non-zero numbers, and non-empty strings, is truthy.</p><p><strong>Example:</strong></p><pre><code>if (0) {\n  console.log(\"This will not run\"); // 0 is falsy\n}\nif (\"\") {\n  console.log(\"This will not run either\"); // empty string is falsy\n}\nif (null) {\n  console.log(\"This will not run as well\"); // null is falsy\n}</code></pre><h2>3. Truthy Values in JavaScript</h2><p>Any value not included in the falsy list is considered truthy. This includes:</p><ul><li>Non-empty strings: <code>\"hello\"</code>, <code>\"0\"</code></li><li>Non-zero numbers: <code>42</code>, <code>-1</code></li><li>Arrays: <code>[]</code> (even empty arrays are truthy)</li><li>Objects: <code>{}</code> (even empty objects are truthy)</li><li>Functions: <code>(function() {})</code></li></ul><p><strong>Example:</strong></p><pre><code>if (\"hello\") {\n  console.log(\"This will run\"); // non-empty string is truthy\n}\nif (42) {\n  console.log(\"This will run as well\"); // non-zero number is truthy\n}\nif ([]) {\n  console.log(\"This will also run\"); // empty array is truthy\n}</code></pre><h2>4. Using Truthy and Falsy Values in Conditionals</h2><p>JavaScript uses truthy and falsy values in conditional statements to determine which code block should execute. This can simplify code by allowing implicit checks.</p><p><strong>Example:</strong></p><pre><code>let username = \"\"; // empty string is falsy\nif (username) {\n  console.log(\"Welcome, \" + username);\n} else {\n  console.log(\"Please provide a username\");\n}</code></pre><p>Since <code>username</code> is an empty string, it is falsy, and the <code>else</code> block executes, outputting \"Please provide a username\".</p><h2>5. Logical Operators with Truthy and Falsy Values</h2><ul><li><strong>Logical AND (&&)</strong>: Returns the first falsy value or the last value if all are truthy.</li><li><strong>Logical OR (||)</strong>: Returns the first truthy value or the last value if all are falsy.</li><li><strong>Logical NOT (!)</strong>: Converts a truthy value to false and a falsy value to true.</li></ul><p><strong>Examples:</strong></p><pre><code>// Logical OR\nconst name = \"\" || \"Default Name\";\nconsole.log(name); // \"Default Name\" because \"\" is falsy\n\n// Logical AND\nconst isValid = 1 && \"Valid\";\nconsole.log(isValid); // \"Valid\" because both values are truthy, so it returns the last one\n\n// Logical NOT\nconst isNotEmpty = !(\"\");\nconsole.log(isNotEmpty); // true because \"\" is falsy, and ! reverses it to true</code></pre><h2>6. Practical Uses of Truthy/Falsy Values</h2><ul><li><strong>Default Values</strong>: Using <code>||</code> to set default values if a variable is falsy.</li></ul><pre><code>let name = userInput || \"Guest\"; // if userInput is falsy, name will be \"Guest\"</code></pre><ul><li><strong>Short-Circuit Evaluation</strong>: Using <code>&&</code> and <code>||</code> to conditionally execute code without <code>if</code> statements.</li></ul><pre><code>let isLoggedIn = true;\nisLoggedIn && console.log(\"User is logged in\"); // logs only if isLoggedIn is true</code></pre><ul><li><strong>Nullish Coalescing Operator (??)</strong>: For cases where only <code>null</code> and <code>undefined</code> are considered falsy (introduced in ES2020).</li></ul><pre><code>let username = null;\nconsole.log(username ?? \"Anonymous\"); // Outputs \"Anonymous\"</code></pre><h2>7. Best Practices</h2><ul><li><strong>Explicit Checks</strong>: For critical conditions, especially with <code>0</code>, <code>false</code>, and empty strings, use explicit comparisons to avoid unintended behavior.</li><li><strong>Use === for Type Safety</strong>: When checking if something is exactly <code>null</code>, <code>undefined</code>, or a specific value, use <code>===</code> to avoid type coercion surprises.</li><li><strong>Be Aware of Edge Cases</strong>: Empty arrays and objects are truthy, which can be counterintuitive. For example, <code>[]</code> and <code>{}</code> are truthy even though they are technically empty.</li></ul><p>Understanding truthy and falsy values helps you write more concise and readable code, especially when working with conditionals and logical operators in JavaScript.</p>"
    },
    "FunctionDeclarationAndExpressions": {
        "title": "Function Declarations & Expressions",
        "text": "<p>In JavaScript, functions can be created in two primary ways: function declarations and function expressions. Understanding the difference between these two types of functions is crucial for writing flexible and predictable code.</p><h2>1. Function Declarations</h2><p>A function declaration defines a function with a specific name. It begins with the <code>function</code> keyword and can be called before it appears in the code, thanks to a process called hoisting.</p><p><strong>Syntax:</strong></p><pre><code>function functionName(parameters) {<br>  // function body<br>}</code></pre><p><strong>Example:</strong></p><pre><code>function greet() {<br>  console.log(\"Hello!\");<br>}<br><br>greet(); // \"Hello!\"</code></pre><p><strong>Key Features of Function Declarations:</strong></p><ul><li><strong>Hoisting:</strong> Function declarations are hoisted to the top of their scope, meaning they are available throughout the entire scope where they’re declared, even if called before the function appears in the code.</li><li><strong>Name Requirement:</strong> Function declarations must have a name.</li><li><strong>Self-contained scope:</strong> Variables inside the function are only accessible within it, which provides encapsulation.</li></ul><p><strong>Example with Hoisting:</strong></p><pre><code>sayHello(); // \"Hello there!\"<br><br>function sayHello() {<br>  console.log(\"Hello there!\");<br>}</code></pre><p>Despite <code>sayHello()</code> being called before its definition, the function executes successfully because function declarations are hoisted.</p><h2>2. Function Expressions</h2><p>A function expression creates a function and assigns it to a variable. Since it’s treated like a regular variable assignment, it does not get hoisted in the same way as a function declaration.</p><p><strong>Syntax:</strong></p><pre><code>const functionName = function(parameters) {<br>  // function body<br>};</code></pre><p><strong>Example:</strong></p><pre><code>const greet = function() {<br>  console.log(\"Hello!\");<br>};<br><br>greet(); // \"Hello!\"</code></pre><p><strong>Key Features of Function Expressions:</strong></p><ul><li><strong>No Hoisting:</strong> Unlike function declarations, function expressions are not hoisted. This means you must declare the function before calling it.</li><li><strong>Anonymous Functions:</strong> Function expressions can be anonymous, meaning they don’t need to have a name.</li><li><strong>Assigned to Variables:</strong> Function expressions are typically assigned to variables, making it easy to pass them around as arguments or assign them as properties of objects.</li></ul><p><strong>Example Without Hoisting:</strong></p><pre><code>try {<br>  greet(); // Throws an error: greet is not defined<br>} catch (error) {<br>  console.log(error);<br>}<br><br>const greet = function() {<br>  console.log(\"Hello!\");<br>};</code></pre><h2>3. Named vs. Anonymous Function Expressions</h2><ul><li><strong>Anonymous Function Expressions:</strong> Function expressions are often written without a name, making them anonymous. This is common when passing functions as arguments or immediately invoking them.<br><strong>Example:</strong><pre><code>const add = function(a, b) {<br>  return a + b;<br>};<br>console.log(add(2, 3)); // 5</code></pre></li><li><strong>Named Function Expressions:</strong> Although less common, function expressions can have names. Named function expressions are useful for self-referencing, especially in recursive functions.<br><strong>Example:</strong><pre><code>const factorial = function fact(n) {<br>  return n <= 1 ? 1 : n * fact(n - 1);<br>};<br>console.log(factorial(5)); // 120</code></pre></li></ul><h2>4. Arrow Functions (Special Case of Function Expressions)</h2><p>Arrow functions are a concise way to write function expressions introduced in ES6. Arrow functions are always anonymous and have special behavior for the <code>this</code> keyword.</p><p><strong>Syntax:</strong></p><pre><code>const functionName = (parameters) => {<br>  // function body<br>};</code></pre><p><strong>Example:</strong></p><pre><code>const multiply = (a, b) => a * b;<br>console.log(multiply(2, 3)); // 6</code></pre><p><strong>Arrow Function Characteristics:</strong></p><ul><li><strong>No <code>this</code> binding:</strong> Arrow functions do not have their own <code>this</code> context; they inherit <code>this</code> from the surrounding scope.</li><li><strong>Concise syntax:</strong> Arrow functions allow for single-line returns without curly braces.</li></ul><h2>5. When to Use Function Declarations vs. Function Expressions</h2><ul><li><strong>Function Declarations:</strong><ul><li>Use when you need the function to be available throughout the entire scope due to hoisting.</li><li>Useful when defining utility functions or helper functions at the top level.</li><li>Suitable for code readability and structure when you want a function to be accessible throughout a block or file.</li></ul></li><li><strong>Function Expressions:</strong><ul><li>Use when you want a function to behave like a variable and not be hoisted.</li><li>Useful when passing functions as arguments, returning functions, or attaching functions as properties of objects.</li><li>Ideal for cases where you need more control over when and how the function is used.</li></ul></li></ul><h2>6. Example Comparison</h2><pre><code>// Function Declaration<br>function add(a, b) {<br>  return a + b;<br>}<br><br>// Function Expression<br>const subtract = function(a, b) {<br>  return a - b;<br>};<br><br>// Arrow Function Expression<br>const multiply = (a, b) => a * b;<br><br>console.log(add(2, 3));       // 5<br>console.log(subtract(5, 3));  // 2<br>console.log(multiply(4, 3));  // 12</code></pre><p>In summary, function declarations and expressions each have their use cases in JavaScript. Understanding when to use each one is key to writing more predictable and maintainable code.</p>"
    },
    "ArrowFunctions": {
        "title": "Arrow Functions",
        "text": "<p>Arrow functions have a unique behavior in JavaScript, particularly with how they handle the <code>this</code> context. Unlike traditional functions, arrow functions do not have their own <code>this</code> context. Instead, they inherit the <code>this</code> value from the surrounding lexical scope, which can lead to simpler and more predictable behavior in some cases.</p><h2>1. What is <code>this</code> in JavaScript?</h2><p>In traditional functions, <code>this</code> refers to the object that calls the function. It is determined dynamically at runtime based on the function’s execution context, which can lead to unexpected behavior in some cases, especially with callbacks and nested functions.</p><p><strong>Example:</strong></p><pre><code>function Person(name) {<br>  this.name = name;<br>}<br><br>Person.prototype.sayName = function() {<br>  console.log(this.name);<br>};<br><br>const alice = new Person('Alice');<br>alice.sayName(); // \"Alice\" - `this` refers to the `alice` object</code></pre><h2>2. Arrow Functions and <code>this</code> Binding</h2><p>Arrow functions differ from traditional functions in that they do not have their own <code>this</code>. Instead, they inherit <code>this</code> from the surrounding lexical scope where they were defined. This means that <code>this</code> in an arrow function is fixed at the time the function is created and cannot be changed, even if the arrow function is used as a method, callback, or within a different object context.</p><p><strong>Example:</strong></p><pre><code>const person = {<br>  name: \"Alice\",<br>  sayName: function() {<br>    const printName = () => {<br>      console.log(this.name); // `this` is inherited from `sayName` method<br>    };<br>    printName();<br>  }<br>};<br><br>person.sayName(); // \"Alice\"</code></pre><p>In this example, <code>printName</code> is an arrow function, so it inherits <code>this</code> from the <code>sayName</code> method, which itself has <code>this</code> bound to <code>person</code>. Therefore, <code>this.name</code> correctly refers to \"Alice\".</p><h2>3. Common Use Cases for Arrow Functions with <code>this</code></h2><ul><li><strong>Callbacks and Event Handlers:</strong> Arrow functions are commonly used in callbacks, especially when you want to maintain the context of <code>this</code> without needing to use <code>.bind()</code>.<pre><code>const button = document.querySelector(\"button\");<br><br>button.addEventListener(\"click\", () => {<br>  console.log(this); // `this` will refer to the lexical scope outside of this function<br>});</code></pre>In the code above, <code>this</code> will not refer to the button element (as it would in a traditional function). Instead, it will refer to the scope outside the arrow function, which could be <code>window</code> in this case.</li><li><strong>Object Methods (Avoiding <code>bind</code> for Nested Functions):</strong> Arrow functions can simplify code when you want to preserve the value of <code>this</code> inside nested functions.<pre><code>const user = {<br>  name: \"Bob\",<br>  friends: [\"Alice\", \"Charlie\"],<br>  printFriends() {<br>    this.friends.forEach(friend => {<br>      console.log(`${this.name} knows ${friend}`);<br>    });<br>  }<br>};<br><br>user.printFriends();<br>// Output:<br>// \"Bob knows Alice\"<br>// \"Bob knows Charlie\"</code></pre>Here, <code>this.name</code> in the <code>forEach</code> callback refers to <code>user.name</code> because the arrow function doesn’t have its own <code>this</code> and inherits it from <code>printFriends</code>.</li></ul><h2>4. Differences Between Arrow Functions and Regular Functions with <code>this</code></h2><ul><li><strong>No <code>this</code> Binding:</strong> In arrow functions, <code>this</code> is lexically bound, meaning it comes from the enclosing scope. Regular functions, on the other hand, have their own <code>this</code> context.</li><li><strong>Cannot be Used as Constructors:</strong> Arrow functions cannot be used as constructors. Using <code>new</code> with an arrow function will throw an error because they don’t have their own <code>this</code> or <code>prototype</code>.<pre><code>const Person = (name) => {<br>  this.name = name;<br>};<br><br>const p = new Person(\"Alice\"); // Error: Person is not a constructor</code></pre></li><li><strong>No <code>arguments</code> Object:</strong> Arrow functions don’t have an <code>arguments</code> object. Instead, you’d need to use rest parameters if you want to access the function’s arguments.<pre><code>const showArgs = (...args) => {<br>  console.log(args);<br>};<br><br>showArgs(1, 2, 3); // [1, 2, 3]</code></pre></li></ul><h2>5. Using Arrow Functions Appropriately</h2><ul><li><strong>Good for Callbacks and Methods that Don’t Require Their Own <code>this</code>:</strong> Arrow functions are great for array methods (<code>map</code>, <code>filter</code>, <code>forEach</code>) and other cases where you don’t need a unique <code>this</code> context.</li><li><strong>Avoid Using Arrow Functions as Object Methods if <code>this</code> is Needed Dynamically:</strong> If you need a function to reference an object it’s called on, a regular function is preferable to avoid accidentally capturing an incorrect <code>this</code>.</li><pre><code>const person = {<br>  name: \"Alice\",<br>  greet: () => {<br>    console.log(`Hello, ${this.name}`);<br>  }"
    },
    "ReturnAndFunctionScope": {
        "title": "Return and Function Scope",
        "text":"<p>In JavaScript, understanding the return statement and function scope is essential, as they play a crucial role in how functions work and how data is accessed and manipulated within a program.</p><h3>1. Understanding return in Functions</h3><ul><li>The return statement stops a function’s execution and specifies the value that the function will output to where it was called. If there is no return statement, the function will return undefined by default.</li></ul><p><strong>Basic Example:</strong></p><pre>function add(a, b) { return a + b; } let result = add(2, 3); console.log(result);</pre><p>Here, return a + b; stops the function and sends back the sum of a and b as the result. Without the return, add(2, 3) would evaluate to undefined.</p><ul><li>Returning Early: Sometimes, you may want to exit a function early based on a condition, which can make code more efficient and readable.</li></ul><p><strong>Example of Early Return:</strong></p><pre>function divide(a, b) { if (b === 0) { return \"Cannot divide by zero\"; } return a / b; } console.log(divide(4, 2)); console.log(divide(4, 0));</pre><p>In this case, if b is 0, the function returns a message instead of continuing with the division operation.</p><h3>2. Function Scope</h3><p>Scope defines where variables and functions are accessible within a program. In JavaScript, function scope means that variables declared within a function are only accessible within that function, creating a self-contained environment for each function.</p><ul><li>Local Scope: Variables declared inside a function (with let, const, or var) are scoped to that function and are not accessible outside it. This encapsulation helps prevent variables from interfering with each other across functions.</li></ul><p><strong>Example of Local Scope:</strong></p><pre>function greet() { let message = \"Hello, World!\"; console.log(message); } greet();</pre><p>In this example, message is only accessible within the greet function. Attempting to access message outside the function results in an error because it is out of scope.</p><ul><li>Global Scope: Variables declared outside any function are in the global scope and can be accessed by any function or code in the program. While convenient, global variables can lead to unexpected bugs due to conflicts or unintended overwriting.</li></ul><p><strong>Example of Global Scope:</strong></p><pre>let globalMessage = \"This is global\"; function showMessage() { console.log(globalMessage); } showMessage();</pre><ul><li>Block Scope: Variables declared with let and const inside a block ({ }) are only accessible within that block. This is not specific to functions but is worth noting as it affects variable access.</li></ul><p><strong>Example of Block Scope:</strong></p><pre>if (true) { let blockScoped = \"I exist only in this block\"; console.log(blockScoped); } console.log(blockScoped);</pre><h3>3. Scope Chain and Variable Lookup</h3><p>JavaScript uses a scope chain to look up variables. If a variable isn’t found within the current scope, JavaScript checks the next outer scope until it reaches the global scope. If the variable isn’t found in the global scope, it results in a ReferenceError.</p><p><strong>Example of Scope Chain:</strong></p><pre>let globalVar = \"global\"; function outer() { let outerVar = \"outer\"; function inner() { let innerVar = \"inner\"; console.log(innerVar); console.log(outerVar); console.log(globalVar); } inner(); } outer();</pre><p>Here, innerVar is found in the innermost scope (inside inner), outerVar is found in the outer scope (inside outer), and globalVar is found in the global scope.</p><h3>4. Function Scope and Closures</h3><p>Closures occur when an inner function retains access to variables from an outer function’s scope, even after the outer function has finished executing. This is because the inner function “closes over” its surrounding scope, keeping those variables in memory.</p><p><strong>Example of Closures:</strong></p><pre>function createCounter() { let count = 0; return function() { count++; return count; }; } const counter = createCounter(); console.log(counter()); console.log(counter()); console.log(counter());</pre><p>Here, the createCounter function creates a count variable, and the inner function returned as a closure has access to count, even after createCounter has executed. Each time counter is called, it increments and remembers the count variable.</p><h3>5. Using return and Scope for Encapsulation</h3><p>Function scope and return help encapsulate logic and variables, keeping the function self-contained. This encapsulation is especially useful when working with closures or creating modules in JavaScript, as it allows certain variables to be private and accessible only within the function’s scope.</p><h3>Summary</h3><ul><li>The return statement stops function execution and sends a value back to the caller. Without return, functions return undefined by default.</li><li>Function scope means variables declared within a function are only accessible within that function. This encapsulation helps avoid naming conflicts and keeps variables private.</li><li>Scope chain: JavaScript checks for variable availability in the current scope, then moves to outer scopes as needed.</li><li>Closures allow inner functions to retain access to variables from an outer function’s scope, enabling data persistence even after the outer function completes.</li></ul><p>Mastering return, scope, and closures helps you write modular, predictable code that’s easier to maintain and debug.</p>"
    },
    "DefaultParameters": {
        "title": "Default Parameters",
        "text":"<p>In JavaScript, default parameters allow you to set a default value for a function parameter if no value or undefined is provided when the function is called. This feature was introduced in ES6 and helps make functions more flexible and reduces the need for additional code to check for missing arguments.</p><h3>1. Setting Default Parameters</h3><p>Default parameters are defined by assigning a default value to the parameter in the function definition. If the function is called without that parameter or with undefined as its argument, the default value will be used.</p><p><strong>Syntax:</strong></p><pre>function functionName(parameter = defaultValue) { // function body }</pre><p><strong>Example:</strong></p><pre>function greet(name = \"Guest\") { console.log(\"Hello, \" + name + \"!\"); } greet(\"Alice\"); greet();</pre><p>In this example, the parameter name has a default value of \"Guest\". When greet is called without an argument, name will take on the default value, resulting in \"Hello, Guest!\".</p><h3>2. How Default Parameters Work</h3><ul><li>If a parameter is omitted or explicitly passed as undefined, the default value will be used.</li><li>If a parameter is passed with any other value (even null or 0), the default value will be ignored, and the passed value will be used instead.</li></ul><p><strong>Examples:</strong></p><pre>function printMessage(message = \"Default message\") { console.log(message); } printMessage(); printMessage(undefined); printMessage(null); printMessage(\"Hello!\");</pre><h3>3. Expressions in Default Parameters</h3><p>Default parameters can also be expressions, meaning you can use more complex values, including calculations or even function calls.</p><p><strong>Example:</strong></p><pre>function multiply(a, b = a * 2) { return a * b; } console.log(multiply(5)); console.log(multiply(5, 3));</pre><p>Here, b defaults to a * 2 if no value is provided, which makes it flexible based on the value of a.</p><h3>4. Using Default Parameters with Other Parameters</h3><p>You can use default parameters alongside regular parameters. However, parameters with default values should generally be placed at the end of the parameter list to avoid confusion, as omitted parameters at the end of a function call are treated as undefined.</p><p><strong>Example:</strong></p><pre>function createUser(name, age = 18) { console.log(\"Name:\", name); console.log(\"Age:\", age); } createUser(\"Alice\"); createUser(\"Bob\", 25);</pre><h3>5. Functions as Default Parameters</h3><p>You can also use functions as default parameters. This is useful if the default value needs to be dynamically generated or computed when the function is called.</p><p><strong>Example:</strong></p><pre>function getDefaultGreeting() { return \"Hello, Guest!\"; } function greetUser(greeting = getDefaultGreeting()) { console.log(greeting); } greetUser(); greetUser(\"Hello, Alice!\");</pre><p>In this case, getDefaultGreeting() is only called if greeting is omitted or undefined. This is efficient because the function won’t run unless it’s needed.</p><h3>6. Common Use Cases</h3><ul><li><strong>Setting Default Options in Functions:</strong> Useful for functions with optional parameters, especially for configurations.</li><li><strong>Avoiding undefined Checks:</strong> Default parameters eliminate the need to check if a parameter is undefined before using it.</li><li><strong>Fallback Values:</strong> Useful for providing fallback values when a specific value isn’t provided.</li></ul><p><strong>Example:</strong></p><pre>function makeRequest(url, method = \"GET\") { console.log(`Requesting ${url} with ${method} method`); } makeRequest(\"https://api.example.com\"); makeRequest(\"https://api.example.com\", \"POST\");</pre><h3>7. Best Practices with Default Parameters</h3><ul><li><strong>Place Default Parameters Last:</strong> To avoid confusion and make the function call cleaner, place parameters with default values at the end of the parameter list.</li><li><strong>Use undefined for Missing Arguments:</strong> Only undefined triggers a default parameter; null and other falsy values like 0 or \"\" will not. Be mindful of this to avoid unintended behavior.</li><li><strong>Avoid Side Effects in Default Expressions:</strong> Since default parameters are evaluated each time the function is called, avoid using expressions that may have side effects (e.g., modifying external variables) within default parameters.</li></ul><h3>Summary</h3><ul><li>Default parameters allow you to specify a value for function parameters when no argument or undefined is passed.</li><li>Default parameters are evaluated at call time, so they can be expressions or function calls.</li><li>Place default parameters at the end of the parameter list, and use them to make functions more flexible and concise.</li></ul><p>By using default parameters effectively, you can make functions more robust, predictable, and easier to use, especially in cases where certain parameters may not always need to be provided.</p>"
    },
    "SelectingOfElements": {
        "title": "Selecting Elements in JavaScript",
        "text":"<p>In JavaScript, selecting HTML elements is a fundamental part of interacting with the DOM (Document Object Model). The document.getElementById and querySelector methods are two commonly used ways to access elements in the DOM.</p><h3>1. document.getElementById</h3><ul><li><strong>Purpose:</strong> The document.getElementById method is used to select an element based on its id attribute.</li><li><strong>Syntax:</strong> document.getElementById(id), where id is the id of the element you want to select.</li><li><strong>Return Value:</strong> This method returns the first element with the specified id or null if no element with that id is found.</li></ul><p><strong>Example:</strong></p><pre>&lt;div id=\"main-content\"&gt;Hello, World!&lt;/div&gt;&lt;script&gt; const element = document.getElementById(\"main-content\"); console.log(element.textContent); &lt;/script&gt;</pre><p><strong>Key Points:</strong></p><ul><li>The id attribute must be unique in the HTML document, so document.getElementById is a very efficient and quick way to retrieve an element by its id.</li><li>If the id does not exist in the document, the method will return null.</li></ul><h3>2. document.querySelector</h3><ul><li><strong>Purpose:</strong> The document.querySelector method selects the first element that matches a specified CSS selector.</li><li><strong>Syntax:</strong> document.querySelector(selector), where selector is a CSS selector string (e.g., #id, .class, tag, or any valid CSS selector).</li><li><strong>Return Value:</strong> Returns the first element that matches the selector or null if no matching element is found.</li></ul><p><strong>Example:</strong></p><pre>&lt;div class=\"content\"&gt;Content 1&lt;/div&gt;&lt;div class=\"content\"&gt;Content 2&lt;/div&gt;&lt;script&gt; const element = document.querySelector(\".content\"); console.log(element.textContent); &lt;/script&gt;</pre><p><strong>Key Points:</strong></p><ul><li>querySelector is versatile and allows you to use any valid CSS selector, including #id, .class, [attribute=value], tagName, and even complex selectors.</li><li>It returns only the first matching element. To get all elements that match a selector, use document.querySelectorAll instead.</li></ul><h3>3. querySelectorAll</h3><ul><li><strong>Purpose:</strong> The document.querySelectorAll method selects all elements that match a specified CSS selector.</li><li><strong>Syntax:</strong> document.querySelectorAll(selector), where selector is a CSS selector string.</li><li><strong>Return Value:</strong> Returns a NodeList containing all elements that match the selector. If no matching elements are found, it returns an empty NodeList.</li></ul><p><strong>Example:</strong></p><pre>&lt;div class=\"content\"&gt;Content 1&lt;/div&gt;&lt;div class=\"content\"&gt;Content 2&lt;/div&gt;&lt;script&gt; const elements = document.querySelectorAll(\".content\"); elements.forEach(element =&gt; console.log(element.textContent)); &lt;/script&gt;</pre><p><strong>Key Points:</strong></p><ul><li>Unlike querySelector, querySelectorAll selects all elements matching the selector and returns them in a NodeList, which is similar to an array and supports iteration methods like forEach.</li><li>NodeList is not a true array, so some array methods (like map and filter) don’t work directly without converting it to an array.</li></ul><h3>4. Comparison Between getElementById and querySelector</h3><table><thead><tr><th>Feature</th><th>getElementById</th><th>querySelector</th></tr></thead><tbody><tr><td>Selector type</td><td>id only (e.g., id=\"main\")</td><td>CSS selectors (e.g., #id, .class, [attr=value])</td></tr><tr><td>Return type</td><td>Single element or null</td><td>Single element or null</td></tr><tr><td>Selects</td><td>Only elements with a unique id</td><td>First matching element by CSS selector</td></tr><tr><td>Performance</td><td>Fastest for id selection</td><td>Slightly slower, more versatile</td></tr><tr><td>Limitations</td><td>Limited to unique id attribute</td><td>Works with various selectors, but only returns the first match</td></tr></tbody></table><p><strong>Examples of Different Selectors with querySelector:</strong></p><pre>document.querySelector(\"#main-content\"); document.querySelector(\".header\"); document.querySelector(\"div\"); document.querySelector(\"[data-role='menu']\");</pre><h3>5. Common Use Cases</h3><ul><li><strong>Unique Element Selection with getElementById:</strong> Use getElementById when you need to quickly access a specific element that has a unique id.</li><li><strong>Flexible Selection with querySelector:</strong> Use querySelector when you need more flexibility in selecting elements by class, tag, or complex CSS selectors, especially when you’re only interested in the first match.</li><li><strong>Selecting Multiple Elements with querySelectorAll:</strong> Use querySelectorAll when you want all matching elements, such as applying changes to multiple elements with the same class.</li></ul><h3>6. Example of Using Both getElementById and querySelector</h3><pre>&lt;div id=\"header\" class=\"header\"&gt;Main Header&lt;/div&gt;&lt;div class=\"content\"&gt;First content&lt;/div&gt;&lt;div class=\"content\"&gt;Second content&lt;/div&gt;&lt;script&gt; const header = document.getElementById(\"header\"); console.log(header.textContent); const firstContent = document.querySelector(\".content\"); console.log(firstContent.textContent); const allContents = document.querySelectorAll(\".content\"); allContents.forEach(content =&gt; console.log(content.textContent)); &lt;/script&gt;</pre><h3>Summary</h3><ul><li><strong>getElementById:</strong> is ideal for quick access to an element by its unique id, offering fast performance.</li><li><strong>querySelector:</strong> provides flexibility with CSS selectors, allowing access to any element based on class, ID, attribute, or tag name.</li><li><strong>querySelectorAll:</strong> is perfect for selecting all elements that match a CSS selector, useful when working with groups of elements.</li></ul><p>These selection methods give you the flexibility to access and manipulate elements in various ways, depending on your specific needs in the DOM.</p>"
    },
    "EventHandling": {
        "title": "Event Handling in JavaScript",
        "text": "<p>In JavaScript, event handling is essential for making web pages interactive. By listening for and responding to user actions—like clicks, key presses, or mouse movements—you can create dynamic behavior on a webpage. The main method for handling events is addEventListener, which lets you attach event listeners to elements. These listeners trigger functions called event handlers when an event occurs.</p><p>Here’s a breakdown of how addEventListener works, along with an introduction to the event object, which provides detailed information about the event.</p><h3>1. The addEventListener Method</h3><ul><li><strong>Purpose:</strong> addEventListener attaches an event handler to an element for a specified event type (like \"click\", \"mouseover\", \"keydown\", etc.).</li><li><strong>Syntax:</strong> element.addEventListener(event, handler, options)</li><li><strong>event:</strong> The type of event to listen for, as a string (e.g., \"click\", \"mouseover\", \"submit\").</li><li><strong>handler:</strong> The function to execute when the event occurs.</li><li><strong>options (optional):</strong> Additional options, like capture, once, and passive.</li></ul><p><strong>Example:</strong></p><pre>&lt;button id=\"myButton\"&gt;Click me&lt;/button&gt;&lt;script&gt; const button = document.getElementById(\"myButton\"); button.addEventListener(\"click\", () =&gt; { console.log(\"Button was clicked!\"); }); &lt;/script&gt;</pre><p>In this example, the event listener is attached to a button with id=\"myButton\". When the button is clicked, the handler function executes, logging “Button was clicked!” to the console.</p><h3>2. Removing an Event Listener</h3><p>You can remove an event listener using the removeEventListener method. To do this, you need a reference to the exact function that was used with addEventListener.</p><p><strong>Example:</strong></p><pre>function handleClick() { console.log(\"Button clicked!\"); } button.addEventListener(\"click\", handleClick); button.removeEventListener(\"click\", handleClick);</pre><p>Here, handleClick is removed from the button’s “click” event. Note that if you use an anonymous function in addEventListener, you cannot remove it, as it has no reference.</p><h3>3. The Event Object</h3><p>When an event occurs, an event object is automatically passed to the event handler function. This object contains details about the event and provides methods to control it.</p><p><strong>Example:</strong></p><pre>&lt;button id=\"myButton\"&gt;Click me&lt;/button&gt;&lt;script&gt; const button = document.getElementById(\"myButton\"); button.addEventListener(\"click\", (event) =&gt; { console.log(event); console.log(\"Button ID:\", event.target.id); }); &lt;/script&gt;</pre><p><strong>Key Properties of the Event Object:</strong></p><ul><li><strong>event.type:</strong> The type of event (e.g., \"click\", \"keyup\").</li><li><strong>event.target:</strong> The element on which the event occurred, useful for identifying the event source.</li><li><strong>event.currentTarget:</strong> The element to which the event handler is attached.</li><li><strong>event.preventDefault():</strong> Prevents the default action associated with the event (e.g., stopping form submission on a button click).</li><li><strong>event.stopPropagation():</strong> Stops the event from bubbling up to parent elements.</li></ul><p><strong>Example of preventDefault and stopPropagation:</strong></p><pre>&lt;form id=\"myForm\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;script&gt; const form = document.getElementById(\"myForm\"); form.addEventListener(\"submit\", (event) =&gt; { event.preventDefault(); console.log(\"Form submission prevented\"); }); &lt;/script&gt;</pre><p>Here, event.preventDefault() prevents the form from actually submitting, which is useful for handling form data with JavaScript.</p><h3>4. Event Propagation: Bubbling and Capturing</h3><ul><li><strong>Event Bubbling:</strong> By default, events “bubble up” from the target element to its ancestors in the DOM tree. For example, a click on a button inside a &lt;div&gt; will trigger both the button’s and the &lt;div&gt;’s event listeners.</li><li><strong>Event Capturing:</strong> The capturing phase goes from the outermost element to the target element. This can be controlled with the capture option in addEventListener.</li></ul><p><strong>Example of Bubbling:</strong></p><pre>&lt;div id=\"outerDiv\"&gt; &lt;button id=\"innerButton\"&gt;Click me&lt;/button&gt; &lt;/div&gt;&lt;script&gt; const outerDiv = document.getElementById(\"outerDiv\"); const innerButton = document.getElementById(\"innerButton\"); outerDiv.addEventListener(\"click\", () =&gt; { console.log(\"Div clicked\"); }); innerButton.addEventListener(\"click\", (event) =&gt; { console.log(\"Button clicked\"); event.stopPropagation(); }); &lt;/script&gt;</pre><p>In this example, clicking the button would trigger both the button’s and the div’s event listeners. However, event.stopPropagation() prevents the event from reaching the outer &lt;div&gt;, so only “Button clicked” is logged.</p><h3>5. Options in addEventListener</h3><p>The third parameter of addEventListener is an options object that provides additional control over the event listener behavior:</p><ul><li><strong>capture:</strong> If true, sets the event listener to the capture phase.</li><li><strong>once:</strong> If true, the event listener will be automatically removed after its first execution.</li><li><strong>passive:</strong> If true, indicates that the function will never call preventDefault(). This can improve performance for events like scrolling.</li></ul><p><strong>Example with Options:</strong></p><pre>button.addEventListener(\"click\", handleClick, { once: true, passive: true });</pre><p>Here, once: true ensures the handler executes only once, and passive: true allows the browser to assume that preventDefault() will not be called, optimizing performance.</p><h3>6. Common Use Cases</h3><ul><li><strong>Button Clicks:</strong> Attach click events to buttons for user interaction.</li><li><strong>Form Submissions:</strong> Capture the submit event on forms to validate data or handle submissions via JavaScript.</li><li><strong>Keyboard Events:</strong> Use keydown, keyup, or keypress events to detect and handle keyboard inputs.</li><li><strong>Mouse Events:</strong> Capture mouseover, mouseout, mousemove, etc., for responsive user interactions.</li></ul><h3>Summary</h3><ul><li><strong>addEventListener:</strong> allows you to attach event handlers to elements.</li><li><strong>The event object:</strong> provides information about the event and methods to control it, such as preventDefault() and stopPropagation().</li><li><strong>Event propagation:</strong> includes bubbling and capturing phases, with stopPropagation available to prevent further propagation.</li><li><strong>Event listener options:</strong> (like once, passive, and capture) provide more control over event handling behavior.</li></ul><p>These tools make it possible to add dynamic interactivity to webpages by responding to user actions in a structured and controlled way.</p>"
    },
    "EventBubblingAndDelegation": {
        "title": "Event bubbling and delegation",
        "text":"<h2>Event Bubbling and Delegation</h2><p>Event bubbling and delegation are core concepts in JavaScript event handling, especially when working with multiple elements and dynamically generated content. Understanding these concepts can help make your code more efficient and manageable.</p><h3>1. Event Bubbling</h3><ul><li><strong>Definition:</strong> Event bubbling is a behavior in the DOM where an event triggered on a child element “bubbles up” to its parent elements. This means that if an event occurs on an element, it will first trigger the event handler on that element, and then move up the DOM tree, triggering event handlers on each of its ancestors until it reaches the root (typically the document).</li><li><strong>Example:</strong></li></ul><pre>&lt;div id=\"outerDiv\"&gt;&lt;button id=\"innerButton\"&gt;Click me&lt;/button&gt;&lt;/div&gt;&lt;script&gt;const outerDiv = document.getElementById(\"outerDiv\"); const innerButton = document.getElementById(\"innerButton\"); outerDiv.addEventListener(\"click\", () => { console.log(\"Div clicked\"); }); innerButton.addEventListener(\"click\", () => { console.log(\"Button clicked\"); });&lt;/script&gt;</pre><p>If you click the button, you’ll see the following output: Button clicked, Div clicked.</p><p><strong>Stopping Event Bubbling:</strong> If you want to prevent an event from bubbling up to parent elements, you can use event.stopPropagation().</p><p><strong>Example:</strong></p><pre>innerButton.addEventListener(\"click\", (event) => { event.stopPropagation(); console.log(\"Button clicked\"); });</pre><p>Now, when you click the button, only \"Button clicked\" is logged, as the event does not reach outerDiv.</p><h3>2. Event Delegation</h3><ul><li><strong>Definition:</strong> Event delegation is a technique that leverages event bubbling to manage events on multiple child elements through a single parent element. Instead of attaching event listeners to each child individually, you attach a single listener to a common ancestor. When an event bubbles up to the ancestor, you can determine which child element triggered it by inspecting the event.target property.</li><li><strong>Benefits of Event Delegation:</strong><ul><li>Performance: Reduces the number of event listeners, which is especially beneficial when dealing with a large number of elements or dynamically created elements.</li><li>Dynamic Elements: Handles events on elements added dynamically, since the event listener is on the ancestor.</li></ul></li></ul><p><strong>Example of Event Delegation:</strong></p><pre>&lt;ul id=\"list\"&gt;&lt;li&gt;Item 1&lt;/li&gt;&lt;li&gt;Item 2&lt;/li&gt;&lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;const list = document.getElementById(\"list\"); list.addEventListener(\"click\", (event) => { if (event.target.tagName === \"LI\") { console.log(\"List item clicked:\", event.target.textContent); } });&lt;/script&gt;</pre><p>Here, instead of attaching a click listener to each &lt;li&gt;, you attach a single listener to the &lt;ul&gt;. When an &lt;li&gt; is clicked, the event bubbles up to &lt;ul&gt;, where the listener checks if the event.target is an &lt;li&gt; and logs the item text. This setup works even if new &lt;li&gt; elements are added dynamically.</p><ul><li><strong>event.target vs. event.currentTarget:</strong><ul><li><strong>event.target:</strong> The element that triggered the event (e.g., the actual &lt;li&gt; clicked).</li><li><strong>event.currentTarget:</strong> The element to which the event handler is attached (e.g., &lt;ul&gt; in the example above).</li></ul></li></ul><pre>list.addEventListener(\"click\", (event) => { console.log(\"Clicked element:\", event.target); console.log(\"Handler attached to:\", event.currentTarget); });</pre><h3>3. Practical Use Cases for Event Delegation</h3><ul><li><strong>Dynamically Adding Items:</strong> When creating elements dynamically (e.g., a list of items that can be added or removed), event delegation ensures that events are handled without adding a new listener to each item.</li><li><strong>Handling Multiple Events:</strong> Event delegation is useful when you want to handle events on a large number of similar elements, like a grid of buttons or list items, without attaching an event listener to each one.</li></ul><h3>4. Summary</h3><ul><li><strong>Event Bubbling:</strong> Events start from the target element and bubble up to parent elements. You can prevent bubbling with event.stopPropagation().</li><li><strong>Event Delegation:</strong> A technique that uses bubbling to manage events on multiple child elements by attaching a single listener to a common ancestor. It’s efficient and particularly useful for dynamic elements.</li><li><strong>Using event.target in Delegation:</strong> event.target helps identify the exact child element that triggered the event, allowing you to respond appropriately within the delegated event listener.</li></ul><p>Event bubbling and delegation are powerful techniques that make event handling in JavaScript more efficient and scalable, especially when working with many elements or dynamic content.</p>"
    }
}
