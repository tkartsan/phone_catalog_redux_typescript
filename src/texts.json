{
    "JSTypes": {
        "title": "Primitive and Non-Primitive Types",
        "text": "<h2>Primitive Types</h2><p>Primitive types are immutable and represent simple, basic values. JavaScript has the following primitive types:</p><ol><li><strong>Number:</strong> Represents both integers and floating-point numbers.<ul><li>Examples: 42, 3.14</li><li>Special values include NaN (Not a Number) and Infinity.</li></ul></li><li><strong>String:</strong> Represents a sequence of characters.<ul><li>Examples: \"hello\", 'world'</li></ul></li><li><strong>Boolean:</strong> Represents logical values.<ul><li>Only two possible values: true or false</li></ul></li><li><strong>Undefined:</strong> A variable that has been declared but not assigned a value is undefined.<ul><li>Example: let x; (Here, x is undefined)</li></ul></li><li><strong>Null:</strong> Represents an intentionally empty or non-existent value.<ul><li>Example: let y = null;</li></ul></li><li><strong>Symbol (ES6):</strong> Represents a unique identifier.<ul><li>Example: let sym = Symbol(\"description\");</li></ul></li><li><strong>BigInt (ES2020):</strong> Allows you to represent integers beyond the safe integer limit for Numbers.<ul><li>Example: let bigInt = 1234567890123456789012345678901234567890n;</li></ul></li></ol><h2>Non-Primitive Types</h2><p>Non-primitive types, also called reference types, hold references to objects and are mutable. JavaScript has one primary non-primitive type:</p><ol><li><strong>Object:</strong> Collections of properties, where each property has a key and a value. Objects can hold complex data structures and include subtypes such as:<ul><li><strong>Arrays:</strong> Ordered collections of values.<ul><li>Example: let arr = [1, 2, 3];</li></ul></li><li><strong>Functions:</strong> Callable objects.<ul><li>Example: function greet() { return \"Hello!\"; }</li></ul></li><li><strong>Dates:</strong> Represent date and time values.<ul><li>Example: let now = new Date();</li></ul></li></ul></li></ol>"
    },
    "TypeChecking": {
        "title": "Type Checking in JavaScript",
        "text":"<p>To check a type in JavaScript, you can use:</p><ul><li><code>typeof</code> operator for most primitive types.</li><li><code>Array.isArray()</code> specifically for arrays.</li><li><code>instanceof</code> for complex objects like custom objects or classes.</li></ul>"
    },
    "VariablesDeclaration": {
        "title": "Variables",
        "text": "<h2>1. Variable Declarations and Scope Types</h2><ul><li><code>let</code>: This variable is block-scoped, meaning it only exists within the specific block (like a function, loop, or { } code block) in which it’s defined. You can reassign its value.</li><li><code>const</code>: This is also block-scoped. Its value is constant (cannot be reassigned), though objects or arrays assigned to it can have their internal contents modified.</li><li><code>var</code>: An older way to declare variables, which is function-scoped. It is accessible within the function it’s defined in, or globally if not in a function, and can be redeclared and reassigned.</li></ul><h2>2. Scope Levels</h2><ul><li><strong>Global Scope</strong>: Variables declared outside any function or block are globally scoped, meaning they can be accessed anywhere in the code.</li><li><strong>Function Scope</strong>: Variables declared within a function (e.g., with var) are only accessible within that function.</li><li><strong>Block Scope</strong>: Variables declared with let or const inside any block { } are accessible only within that block.</li></ul><pre><code>let age = 30; // global scope\nfunction updateAge() {\n    let age = 40; // function-scoped age, separate from global `age`\n    if (true) {\n        const city = \"Paris\"; // block-scoped, only accessible within `if` block\n    }\n    console.log(city); // Error: city is not defined outside of `if` block\n}</code></pre><h2>3. Reassignment and Mutability</h2><ul><li><code>let</code> and <code>var</code>: Both can be reassigned within their scope.</li><li><code>const</code>: Can’t be reassigned, but if it holds an object or array, the internal contents can be modified within its scope.<pre><code>const arr = [1, 2, 3];\narr = []; // error\narr.push(4); // no error, legit</code></pre></li></ul><h2>4. Key Points on Scope</h2><ul><li>Global variables (outside any function or block) can lead to issues if used excessively, as they’re accessible throughout the code and can cause conflicts.</li><li>Local variables (function-scoped or block-scoped) help keep your code modular and predictable by limiting where the variables are accessible.</li><li>Block scoping with let and const makes code safer by reducing the chances of accidentally using or modifying variables outside their intended context.</li></ul><pre><code>function testScope() {\n    if (true) {\n        var x = \"I’m function-scoped with var\";\n        let y = \"I’m block-scoped with let\";\n        const z = \"I’m block-scoped with const\";\n    }\n    console.log(x); // \"I’m function-scoped with var\" - accessible here due to function scope\n    console.log(y); // Error: y is not defined - y is only accessible within the `if` block\n    console.log(z); // Error: z is not defined - z is also block-scoped to `if`\n}\ntestScope();</code></pre><h3>=============</h3><pre><code>function loopScopeWithVar() {\n    for (var i = 0; i < 3; i++) {\n        console.log(\"Inside loop with var:\", i); // 0, 1, 2\n    }\n    console.log(\"Outside loop with var:\", i); // 3 - `i` is still accessible here\n}\nloopScopeWithVar();</code></pre><h3>=============</h3><pre><code>function loopScopeWithLet() {\n    for (let i = 0; i < 3; i++) {\n        console.log(\"Inside loop with let:\", i); // 0, 1, 2\n    }\n    console.log(\"Outside loop with let:\", i); // Error: i is not defined\n}\nloopScopeWithLet();</code></pre><h3>=============</h3><h2>Asynchronous Example</h2><p>Consider an example with a delay (<code>setTimeout</code>) in the loop to see how var and let handle asynchronous behavior differently.</p><h3>Using var</h3><pre><code>function asyncLoopWithVar() {\n    for (var i = 0; i < 3; i++) {\n        setTimeout(function() {\n            console.log(\"Async with var:\", i); // 3, 3, 3\n        }, 1000);\n    }\n}\nasyncLoopWithVar();</code></pre><p><strong>Explanation:</strong><ul><li>Because <code>var</code> is function-scoped, there’s only one <code>i</code> variable shared across all iterations. By the time the <code>setTimeout</code> callbacks run, the loop has completed, and <code>i</code> has the value 3 in each callback, so “3” is logged three times.</li><li>This happens because <code>var</code> does not create a new instance of <code>i</code> for each loop iteration.</li></ul></p><h3>Using let</h3><pre><code>function asyncLoopWithLet() {\n    for (let i = 0; i < 3; i++) {\n        setTimeout(function() {\n            console.log(\"Async with let:\", i); // 0, 1, 2\n        }, 1000);\n    }\n}\nasyncLoopWithLet();</code></pre><p><strong>Explanation:</strong><ul><li>With <code>let</code>, each iteration of the loop has its own block-scoped instance of <code>i</code>. Each <code>setTimeout</code> callback captures the value of <code>i</code> specific to that loop iteration, so it logs “0”, “1”, and “2” as expected.</li><li>This happens because <code>let</code> provides a new instance of <code>i</code> within the loop for each cycle, preserving the correct value even when the loop is asynchronous.</li></ul></p>"
    },
    "JSSClassesAndPrototypes": {
        "title": "Js classes and prototypes",
        "text":"<p>In JavaScript, classes and prototypes provide a way to create objects and structure code for reusability. Here’s a straightforward breakdown:</p><h2>1. Prototypes</h2><ul><li>Every JavaScript object has an internal property called [[Prototype]], linking it to another object. This linked object is called its prototype.</li><li>Prototypes allow objects to inherit properties and methods from other objects. When you try to access a property or method on an object, JavaScript will look for it on the object itself and, if not found, continue searching up the prototype chain.</li></ul><pre><code>function Animal(type) {\n    this.type = type;\n}\nAnimal.prototype.makeSound = function() {\n    console.log(\"Some sound\");\n};\nconst dog = new Animal(\"Dog\");\ndog.makeSound(); // Outputs: \"Some sound\"</code></pre><p>Here, makeSound is on Animal’s prototype, so all Animal instances like dog can use it.</p><h2>2. Classes</h2><ul><li>JavaScript class syntax provides a clearer, more concise way to create objects with prototypes and inheritance.</li><li>Classes are essentially “syntactic sugar” over JavaScript’s prototype-based inheritance. This means that under the hood, classes are still based on prototypes.</li><li>A class can have a constructor (like a function), and methods are added to the class’s prototype.</li></ul><pre><code>class Animal {\n    constructor(type) {\n        this.type = type;\n    }\n    makeSound() {\n        console.log(\"Some sound\");\n    }\n}\nconst cat = new Animal(\"Cat\");\ncat.makeSound(); // Outputs: \"Some sound\"</code></pre><p>Here, the makeSound method is part of the Animal class prototype, so instances of Animal like cat inherit it.</p><h2>3. Inheritance</h2><ul><li>Classes support inheritance, allowing you to create subclasses.</li><li>By using the extends keyword, you can create a new class based on an existing one, inheriting its properties and methods.</li></ul><pre><code>class Dog extends Animal {\n    makeSound() {\n        console.log(\"Woof!\");\n    }\n}\nconst myDog = new Dog(\"Dog\");\nmyDog.makeSound(); // Outputs: \"Woof!\"</code></pre><p>The Dog class inherits from Animal, but it overrides the makeSound method.</p><h2>Key Points</h2><ul><li>Prototypes enable inheritance by linking objects to each other.</li><li>Classes offer a modern, cleaner syntax for creating objects and handling inheritance.</li><li>Instances of a class or constructor function share methods through the prototype chain.</li></ul><p>Both approaches enable code reuse and modularization, with classes generally being easier to read and understand in modern JavaScript.</p>"
    },
    "CoercionAndConversion": {
        "title": "Type coercion and conversion",
        "text":"<p>Type coercion and conversion are important concepts in JavaScript, especially for junior developers. They play a big role in how JavaScript handles values during comparisons, assignments, and other operations. Here’s a breakdown of these concepts with examples:</p><h2>1. Type Coercion vs. Type Conversion</h2><ul><li><strong>Type Coercion</strong>: This is an automatic or implicit conversion of values from one data type to another. JavaScript automatically coerces types in certain operations, often leading to unexpected results if not carefully handled.</li><li><strong>Type Conversion</strong>: This is an explicit conversion where we intentionally convert one data type to another using built-in methods like <code>String()</code>, <code>Number()</code>, or <code>Boolean()</code>.</li></ul><h2>2. Examples of Type Coercion in Comparisons</h2><p>Type coercion is particularly noticeable with the <code>==</code> operator, where JavaScript tries to convert both sides to the same type before comparing. The <code>===</code> operator (strict equality) does not perform type coercion, meaning both the value and type must match.</p><ul><li><strong>Loose Equality (==)</strong>:</li></ul><pre><code>console.log(5 == '5'); // true, because '5' is coerced to 5\nconsole.log(false == 0); // true, because false is coerced to 0\nconsole.log('' == 0); // true, because '' is coerced to 0\nconsole.log(null == undefined); // true, special case in JavaScript</code></pre><ul><li><strong>Strict Equality (===)</strong>:</li></ul><pre><code>console.log(5 === '5'); // false, because the types (number and string) are different\nconsole.log(false === 0); // false, because false is a boolean and 0 is a number\nconsole.log('' === 0); // false, different types\nconsole.log(null === undefined); // false, different types</code></pre><h2>3. Common Coercion Cases</h2><ul><li><strong>Boolean Coercion</strong>: JavaScript has rules for truthy and falsy values, so certain values convert to true or false in contexts that expect booleans.</li><li>Falsy values include: <code>0</code>, <code>''</code> (empty string), <code>null</code>, <code>undefined</code>, <code>NaN</code>, and <code>false</code>.</li><li>Everything else is truthy.</li></ul><pre><code>console.log(Boolean(0)); // false\nconsole.log(Boolean('')); // false\nconsole.log(Boolean('Hello')); // true</code></pre><ul><li><strong>Number Coercion</strong>: When performing mathematical operations, JavaScript tries to coerce values to numbers.</li></ul><pre><code>console.log('5' - 3); // 2, because '5' is coerced to 5\nconsole.log('5' + 3); // '53', because + with a string leads to string concatenation</code></pre><h2>4. Explicit Type Conversion</h2><ul><li><strong>String Conversion</strong>:</li></ul><pre><code>console.log(String(123)); // '123'\nconsole.log((123).toString()); // '123'</code></pre><ul><li><strong>Number Conversion</strong>:</li></ul><pre><code>console.log(Number('123')); // 123\nconsole.log(Number('')); // 0\nconsole.log(parseInt('123px', 10)); // 123, ignores non-numeric part</code></pre><ul><li><strong>Boolean Conversion</strong>:</li></ul><pre><code>console.log(Boolean(1)); // true\nconsole.log(Boolean(0)); // false</code></pre><h2>5. Best Practices</h2><ul><li>Use <code>===</code> for comparisons to avoid unexpected coercion.</li><li>Be mindful of truthy and falsy values in conditions.</li><li>Convert types explicitly when you need a specific type.</li></ul>"
    },
    "Conditionals": {
        "title": "Conditionals",
        "text":"<p>Conditionals are essential in JavaScript for controlling the flow of a program. They allow you to execute different code blocks based on certain conditions. Here’s an overview of how <code>if</code>, <code>else</code>, and <code>switch</code> work, along with best practices and examples.</p><h2>1. if Statement</h2><p>The <code>if</code> statement is used to execute a block of code only if a specified condition is true.</p><pre><code>let age = 18;\nif (age >= 18) {\n  console.log(\"You are an adult.\");\n}</code></pre><p>In this example, the message \"You are an adult.\" will only be logged if <code>age</code> is 18 or greater.</p><h2>2. if...else Statement</h2><p>The <code>if...else</code> statement allows you to specify an alternative block of code that runs if the <code>if</code> condition is false.</p><pre><code>let age = 16;\nif (age >= 18) {\n  console.log(\"You are an adult.\");\n} else {\n  console.log(\"You are not an adult.\");\n}</code></pre><p>Here, if <code>age</code> is less than 18, the message \"You are not an adult.\" will be logged.</p><h2>3. else if Statement</h2><p>The <code>else if</code> statement allows you to chain multiple conditions. The first condition that evaluates to true will execute its associated code block, and the rest will be ignored.</p><pre><code>let score = 85;\nif (score >= 90) {\n  console.log(\"Grade: A\");\n} else if (score >= 80) {\n  console.log(\"Grade: B\");\n} else if (score >= 70) {\n  console.log(\"Grade: C\");\n} else {\n  console.log(\"Grade: F\");\n}</code></pre><p>In this case, if <code>score</code> is between 80 and 89, the output will be \"Grade: B\". Only one of the conditions will be executed.</p><h2>4. switch Statement</h2><p>The <code>switch</code> statement is an alternative to multiple <code>if...else if</code> statements. It compares a single expression against multiple possible values. The <code>switch</code> statement is often used when you have a single variable that could be one of many values.</p><pre><code>let fruit = \"apple\";\nswitch (fruit) {\n  case \"apple\":\n    console.log(\"You chose an apple.\");\n    break;\n  case \"banana\":\n    console.log(\"You chose a banana.\");\n    break;\n  case \"orange\":\n    console.log(\"You chose an orange.\");\n    break;\n  default:\n    console.log(\"Unknown fruit.\");\n}</code></pre><p>In this example, if <code>fruit</code> is \"apple\", the message \"You chose an apple.\" is logged. The <code>break</code> statement prevents the code from executing subsequent cases.</p><h2>5. Nested Conditionals</h2><p>You can nest <code>if</code>, <code>else if</code>, <code>else</code>, and even <code>switch</code> statements inside each other to create more complex logic. However, avoid deep nesting as it can make the code harder to read.</p><pre><code>let age = 20;\nlet hasPermission = true;\nif (age >= 18) {\n  if (hasPermission) {\n    console.log(\"You can enter the event.\");\n  } else {\n    console.log(\"You need permission to enter.\");\n  }\n} else {\n  console.log(\"You are too young to enter.\");\n}</code></pre><h2>6. Ternary Operator (Shorter Conditional)</h2><p>For simple conditions, you can use the ternary operator (<code>? :</code>) as a shorthand for <code>if...else</code>.</p><pre><code>let age = 20;\nlet message = age >= 18 ? \"You are an adult.\" : \"You are not an adult.\";\nconsole.log(message);</code></pre><p>This will output \"You are an adult.\" if <code>age</code> is 18 or older; otherwise, it outputs \"You are not an adult.\"</p><h2>7. Best Practices for Conditionals</h2><ul><li>Use <code>===</code> for Comparison: To avoid type coercion issues, prefer <code>===</code> over <code>==</code>.</li><li>Keep Conditions Simple: Break down complex conditions into smaller functions if necessary.</li><li>Switch for Specific Values: Use <code>switch</code> statements when comparing a single variable against multiple constant values. Use <code>if...else</code> when you have complex conditions or ranges.</li><li>Avoid Deep Nesting: Deeply nested <code>if</code> statements can make code hard to read. Use <code>return</code> statements in functions to exit early when possible.</li><li>Ternary Operator for Simple Assignments: Use the ternary operator for short, single-line conditional assignments, but avoid it in complex conditions to maintain readability.</li></ul><p>Conditionals are powerful for building logic in applications, and understanding these structures well will help you write cleaner, more efficient JavaScript code.</p>"
    },
    "Loops": {
        "title": "Loops",
        "text":"<p>Loops are fundamental in JavaScript, allowing you to execute a block of code multiple times based on a condition. Here’s a breakdown of the main types of loops in JavaScript:</p><h2>1. for Loop</h2><p>The <code>for</code> loop is commonly used when you know the exact number of iterations or want to iterate over a range of values.</p><p><strong>Syntax:</strong></p><pre><code>for (initialization; condition; increment) {\n  // Code to execute on each iteration\n}</code></pre><p><strong>Example:</strong></p><pre><code>for (let i = 0; i < 5; i++) {\n  console.log(i);\n}</code></pre><p>This loop will log numbers 0 through 4. Here’s how each part works:</p><ul><li><strong>Initialization</strong>: <code>let i = 0</code> sets the starting value.</li><li><strong>Condition</strong>: <code>i < 5</code> checks if the loop should continue.</li><li><strong>Increment</strong>: <code>i++</code> increases <code>i</code> by 1 after each loop.</li></ul><h2>2. while Loop</h2><p>The <code>while</code> loop is useful when the number of iterations is not known beforehand. It continues to execute as long as the condition is true.</p><p><strong>Syntax:</strong></p><pre><code>while (condition) {\n  // Code to execute on each iteration\n}</code></pre><p><strong>Example:</strong></p><pre><code>let i = 0;\nwhile (i < 5) {\n  console.log(i);\n  i++;\n}</code></pre><p>This loop works similarly to the for loop above, logging numbers 0 through 4. Note that you must manually update the variable <code>i</code> within the loop; otherwise, you’ll end up with an infinite loop.</p><h2>3. do...while Loop</h2><p>The <code>do...while</code> loop is similar to the <code>while</code> loop, but it guarantees that the loop body will execute at least once, even if the condition is false.</p><p><strong>Syntax:</strong></p><pre><code>do {\n  // Code to execute\n} while (condition);</code></pre><p><strong>Example:</strong></p><pre><code>let i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i < 5);</code></pre><p>This example will log numbers 0 through 4, just like the previous loops. However, the <code>do</code> block executes first before checking the <code>while</code> condition.</p><h2>4. for...of Loop</h2><p>The <code>for...of</code> loop is specifically used for iterating over iterable objects, such as arrays, strings, and other collections.</p><p><strong>Syntax:</strong></p><pre><code>for (const element of iterable) {\n  // Code to execute for each element\n}</code></pre><p><strong>Example:</strong></p><pre><code>const colors = ['red', 'green', 'blue'];\nfor (const color of colors) {\n  console.log(color);\n}</code></pre><p>This will log each color in the array: 'red', 'green', and 'blue'. The <code>for...of</code> loop is often preferred for iterating over arrays since it’s cleaner and avoids the need for indexing.</p><h2>5. for...in Loop</h2><p>The <code>for...in</code> loop is used for iterating over the keys (property names) of an object. It’s also technically usable with arrays, but it’s generally not recommended for that purpose, as it iterates over all enumerable properties, including inherited ones.</p><p><strong>Syntax:</strong></p><pre><code>for (const key in object) {\n  // Code to execute for each key\n}</code></pre><p><strong>Example:</strong></p><pre><code>const person = { name: 'Alice', age: 25, city: 'Paris' };\nfor (const key in person) {\n  console.log(key, person[key]);\n}</code></pre><p>This will log each key-value pair:</p><ul><li><code>name Alice</code></li><li><code>age 25</code></li><li><code>city Paris</code></li></ul><p><strong>Note:</strong> Avoid using <code>for...in</code> on arrays. It will also iterate over inherited properties, which can lead to unexpected results. For arrays, use <code>for</code>, <code>for...of</code>, or array methods like <code>.forEach()</code>.</p><h2>6. Loop Control Statements</h2><ul><li><strong>break</strong>: Exits the loop immediately.</li><li><strong>continue</strong>: Skips to the next iteration of the loop.</li></ul><p><strong>Example with break and continue:</strong></p><pre><code>for (let i = 0; i < 5; i++) {\n  if (i === 3) break; // Exit the loop if i is 3\n  if (i === 1) continue; // Skip the rest of the loop for i = 1\n  console.log(i);\n}</code></pre><p>This will output 0, 2, and then stop at 3.</p><h2>7. Best Practices</h2><ul><li>Use <code>for</code> loops when you need control over the index.</li><li>Use <code>for...of</code> loops when iterating directly over values in arrays or other iterables.</li><li>Use <code>for...in</code> for iterating over object properties but avoid it with arrays.</li><li>Avoid infinite loops by making sure your condition will eventually be false.</li><li>Consider array methods like <code>.forEach()</code>, <code>.map()</code>, or <code>.filter()</code> as alternatives to loops for more readable and functional code.</li></ul><p>By understanding these loops and their specific use cases, you can iterate through data effectively and write cleaner, more efficient code in JavaScript.</p><h2>Declarative vs. Imperative Approaches</h2><p>When working with loops, the choice between a declarative and an imperative approach can impact code readability, maintainability, and clarity. Here’s how each approach compares, especially in the context of JavaScript loops:</p><h3>1. Imperative Approach</h3><ul><li>The imperative approach focuses on describing how to accomplish a task step-by-step.</li><li>Traditional loops like <code>for</code>, <code>while</code>, and <code>for...of</code> are imperative because they require you to define the steps explicitly for each iteration.</li><li>With an imperative approach, you need to manage the control flow, set up initial values, define conditions, and handle increments or updates directly.</li></ul><p><strong>Example (Imperative):</strong></p><pre><code>const numbers = [1, 2, 3, 4, 5];\nlet sum = 0;\nfor (let i = 0; i < numbers.length; i++) {\n  sum += numbers[i];\n}\nconsole.log(sum); // Outputs: 15</code></pre><p>Here, each step of the iteration is controlled manually: initializing <code>i</code>, setting the loop condition, updating <code>i</code>, and managing <code>sum</code> updates.</p><h3>2. Declarative Approach</h3><ul><li>The declarative approach focuses on describing what you want to achieve, rather than how to do it step-by-step.</li><li>JavaScript’s array methods like <code>.map()</code>, <code>.filter()</code>, <code>.reduce()</code>, and <code>.forEach()</code> are declarative, as they abstract the iteration details, letting you focus on the desired outcome.</li><li>With a declarative approach, you express the intent directly, making code easier to read and understand without managing loop mechanics manually.</li></ul><p><strong>Example (Declarative):</strong></p><pre><code>const numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((acc, number) => acc + number, 0);\nconsole.log(sum); // Outputs: 15</code></pre><p>Here, <code>.reduce()</code> directly conveys that you want to calculate the sum of all items in the array, without managing the loop steps manually.</p><h3>3. Advantages of Declarative Over Imperative in JavaScript</h3><ul><li><strong>Readability</strong>: Declarative code is often more readable and concise, as it abstracts away the control flow, focusing on the task rather than the mechanics.</li><li><strong>Less Prone to Errors</strong>: Since you’re not manually handling increments, indexes, or loop conditions, there’s less chance of off-by-one errors or infinite loops.</li><li><strong>Functional Style</strong>: Declarative methods like <code>.map()</code>, <code>.filter()</code>, and <code>.reduce()</code> encourage a functional programming style, which can lead to cleaner, modular code that’s easier to test and debug.</li><li><strong>Easier Refactoring</strong>: Declarative code is often easier to refactor and modify because it encapsulates behavior rather than steps.</li></ul><h3>4. Choosing Between Declarative and Imperative</h3><ul><li><strong>When to Use Declarative</strong>: Prefer declarative methods like <code>.map()</code>, <code>.filter()</code>, <code>.reduce()</code>, and <code>.forEach()</code> when working with arrays, as they are designed to handle common iteration tasks cleanly.</li><li><strong>When to Use Imperative</strong>: Use traditional loops (<code>for</code>, <code>while</code>) when you need fine-grained control over the iteration or when performance is a key concern, as traditional loops can sometimes be faster in performance-critical applications.</li></ul><h3>5. Example Comparison</h3><p><strong>Imperative with for Loop:</strong></p><pre><code>const numbers = [1, 2, 3, 4, 5];\nconst doubled = [];\nfor (let i = 0; i < numbers.length; i++) {\n  doubled.push(numbers[i] * 2);\n}\nconsole.log(doubled); // [2, 4, 6, 8, 10]</code></pre><p><strong>Declarative with .map():</strong></p><pre><code>const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(number => number * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]</code></pre><p>In this example, <code>.map()</code> makes the intent clear (“double each number”) without requiring explicit setup and incrementing as in the <code>for</code> loop.</p><h2>Summary</h2><ul><li><strong>Imperative</strong>: Focuses on the steps to complete a task (e.g., <code>for</code> loop), useful for precise control.</li><li><strong>Declarative</strong>: Focuses on the outcome (e.g., <code>.map()</code>, <code>.reduce()</code>), often more readable and concise.</li></ul><p>For most cases, the declarative approach is preferred in JavaScript when working with collections, as it simplifies code and aligns with JavaScript’s functional programming capabilities.</p>"
    },
    "TruthyandFalsyValues": {
        "title": "Truthy and Falsy Values",
        "text":"<p>In JavaScript, understanding truthy and falsy values is essential because they influence conditionals and logical operations. Truthy and falsy values determine whether an expression evaluates to true or false in a boolean context, such as in <code>if</code> statements, loops, and logical operators.</p><h2>1. Truthy and Falsy Values</h2><ul><li><strong>Truthy</strong>: A value is considered “truthy” if it evaluates to true in a boolean context.</li><li><strong>Falsy</strong>: A value is “falsy” if it evaluates to false in a boolean context.</li></ul><h2>2. Falsy Values in JavaScript</h2><p>In JavaScript, there are exactly seven values that are considered falsy:</p><ul><li><code>false</code></li><li><code>0</code> (and <code>-0</code>)</li><li><code>\"\"</code> (empty string)</li><li><code>null</code></li><li><code>undefined</code></li><li><code>NaN</code> (Not-a-Number)</li></ul><p>Any other value, including objects, arrays, non-zero numbers, and non-empty strings, is truthy.</p><p><strong>Example:</strong></p><pre><code>if (0) {\n  console.log(\"This will not run\"); // 0 is falsy\n}\nif (\"\") {\n  console.log(\"This will not run either\"); // empty string is falsy\n}\nif (null) {\n  console.log(\"This will not run as well\"); // null is falsy\n}</code></pre><h2>3. Truthy Values in JavaScript</h2><p>Any value not included in the falsy list is considered truthy. This includes:</p><ul><li>Non-empty strings: <code>\"hello\"</code>, <code>\"0\"</code></li><li>Non-zero numbers: <code>42</code>, <code>-1</code></li><li>Arrays: <code>[]</code> (even empty arrays are truthy)</li><li>Objects: <code>{}</code> (even empty objects are truthy)</li><li>Functions: <code>(function() {})</code></li></ul><p><strong>Example:</strong></p><pre><code>if (\"hello\") {\n  console.log(\"This will run\"); // non-empty string is truthy\n}\nif (42) {\n  console.log(\"This will run as well\"); // non-zero number is truthy\n}\nif ([]) {\n  console.log(\"This will also run\"); // empty array is truthy\n}</code></pre><h2>4. Using Truthy and Falsy Values in Conditionals</h2><p>JavaScript uses truthy and falsy values in conditional statements to determine which code block should execute. This can simplify code by allowing implicit checks.</p><p><strong>Example:</strong></p><pre><code>let username = \"\"; // empty string is falsy\nif (username) {\n  console.log(\"Welcome, \" + username);\n} else {\n  console.log(\"Please provide a username\");\n}</code></pre><p>Since <code>username</code> is an empty string, it is falsy, and the <code>else</code> block executes, outputting \"Please provide a username\".</p><h2>5. Logical Operators with Truthy and Falsy Values</h2><ul><li><strong>Logical AND (&&)</strong>: Returns the first falsy value or the last value if all are truthy.</li><li><strong>Logical OR (||)</strong>: Returns the first truthy value or the last value if all are falsy.</li><li><strong>Logical NOT (!)</strong>: Converts a truthy value to false and a falsy value to true.</li></ul><p><strong>Examples:</strong></p><pre><code>// Logical OR\nconst name = \"\" || \"Default Name\";\nconsole.log(name); // \"Default Name\" because \"\" is falsy\n\n// Logical AND\nconst isValid = 1 && \"Valid\";\nconsole.log(isValid); // \"Valid\" because both values are truthy, so it returns the last one\n\n// Logical NOT\nconst isNotEmpty = !(\"\");\nconsole.log(isNotEmpty); // true because \"\" is falsy, and ! reverses it to true</code></pre><h2>6. Practical Uses of Truthy/Falsy Values</h2><ul><li><strong>Default Values</strong>: Using <code>||</code> to set default values if a variable is falsy.</li></ul><pre><code>let name = userInput || \"Guest\"; // if userInput is falsy, name will be \"Guest\"</code></pre><ul><li><strong>Short-Circuit Evaluation</strong>: Using <code>&&</code> and <code>||</code> to conditionally execute code without <code>if</code> statements.</li></ul><pre><code>let isLoggedIn = true;\nisLoggedIn && console.log(\"User is logged in\"); // logs only if isLoggedIn is true</code></pre><ul><li><strong>Nullish Coalescing Operator (??)</strong>: For cases where only <code>null</code> and <code>undefined</code> are considered falsy (introduced in ES2020).</li></ul><pre><code>let username = null;\nconsole.log(username ?? \"Anonymous\"); // Outputs \"Anonymous\"</code></pre><h2>7. Best Practices</h2><ul><li><strong>Explicit Checks</strong>: For critical conditions, especially with <code>0</code>, <code>false</code>, and empty strings, use explicit comparisons to avoid unintended behavior.</li><li><strong>Use === for Type Safety</strong>: When checking if something is exactly <code>null</code>, <code>undefined</code>, or a specific value, use <code>===</code> to avoid type coercion surprises.</li><li><strong>Be Aware of Edge Cases</strong>: Empty arrays and objects are truthy, which can be counterintuitive. For example, <code>[]</code> and <code>{}</code> are truthy even though they are technically empty.</li></ul><p>Understanding truthy and falsy values helps you write more concise and readable code, especially when working with conditionals and logical operators in JavaScript.</p>"
    }
}
